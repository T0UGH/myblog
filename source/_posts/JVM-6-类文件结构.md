---
title: '[JVM][6][类文件结构]'
date: 2020-02-19 20:32:35
tags:
    - jvm
    - java
categories:
    - jvm
---
## 第 6 章 类文件结构

### 6.1 概述

近几年内涌现了大量虚拟机以及大量建立在虚拟机上的程序设计语言，把编写的程序编译成二进制本地机器码(Native Code)不再是唯一选择，越来越多的程序语言选择了与操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式

### 6.2 无关性的基石

各种各样的针对不同操作系统设计的Java虚拟机，载入和执行一种与平台无关的字节码，就实现了“一次编写，到处运行”。因此，各个不同平台的Java虚拟机以及所有平台都统一支持的程序存储格式——字节码（Byte Code）是构成平台无关性的基石。

除此之外还出现了大量运行在Java虚拟机之上的语言，比如Kotlin、Clojure、Groovy等，使得Java虚拟机逐渐具备语言无关性

Java虚拟机不与任何程序语言绑定，它只与`Class`文件这种特定的二进制文件格式所关联，`Class`文件中包含了`Java`虚拟机指令集、符号表以及若干其他辅助信息。图灵完备的字节码格式，保证了任何一门功能性语言都可以表示为一个能被Java虚拟机所接受的`Class`文件，如下图

![](JVM-6-类文件结构\200218_0.png)

### 6.3 Class类文件结构

Class文件结构的内容，绝大部分在1997年发布的第一版《Java虚拟机规范》中已经定义好了。它是一组以8个字节为基础单位的二进制流，中间没有任何分割符

Class文件格式采用一种类似C语言结构体的伪结构来存储数据，这种伪结构只有两种数据类型：“无符号数”和“表”
- 无符号数用来描述数字、索引引用、数量值或按照UTF-8编码组成的字符串值
- 表是由多个无符号数或其他表作为数据项构成的复合数据类型

#### 6.3.1 魔数和Class文件的版本

每个Class文件的头4个字节被称为魔数，它用来确定一个文件是否为一个能被虚拟机接受的Class文件，Class文件的魔数固定为`0xCAFEBABE`

紧接着魔数的4个字节存储的是Class文件的版本号，Java的版本号是从45开始的，每个Java大版本版本号加1。高版本的JDK可以向下兼容以前版本的Class文件，但是不能运行以后版本的Class文件

#### 6.3.2 常量池

常量池可以被喻为class文件的资源仓库。它主要存储两大类型的常量：字面量(Literal)和符号引用(symbolic References)。

字面量接近于Java语言中的常量，如文本字符串、被声明为final的常量值等

符号引用则属于编译原理方面的概念，主要包括
- 被模块到处或开放的包（Package）
- 类和接口的全限定名（Fully Qualified Name）
- 字段的名称和描述符（Descriptor）
- 方法的名称和描述符
- 方法句柄和方法类型
- 动态调用点和动态常量

#### 6.3.3 访问标志

在常量池结束后，接下来的两个标志是访问标志，这个标志用来识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型等

#### 6.3.4 类索引、父类索引与结构索引集合

类索引用来定义这个类的全限定名
父类索引用来定义这个类的父类的全限定名
接口索引描述这个类实现了哪些接口

#### 6.3.5 字段表集合

用来描述类中的静态变量或者实例级变量。包括字段的修饰标志（private、static等）、描述符(字段类型，例如`int`的描述符是`i`)、字段的简单名称索引(就是变量名)

#### 6.3.6 方法表集合

与字段表集合类似，存储除了方法体之外的方法信息，方法体放在了方法属性表的`Code`类型中

#### 6.3.7 属性表集合

Class文件、字段表、方法表都可以携带自己的__属性表__集合

与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制比较宽松，不再要求各个属性表具有严格顺序

##### 1 Code属性

用于方法属性表，Java程序方法体里面的代码经过Javac编译器处理后，最终变成字节码指令存储在Code属性内

##### 2 Exceptions属性

用于方法属性表，列举出方法中可能抛出的受查异常(Checked Exception)，也就是方法描述时在throws关键字后面列举的异常

##### 3 LineNumberTable属性

lineNumberTable用来描述Java源码行号与字节码行号之间的对应关系。这样当程序运行抛出异常时，可以得知出错的行号


##### 4 LocalVaribleTable属性

用来描述运行时栈帧中的局部变量表的变量与Java源代码中定义的变量之间的关系，这样当别人引用方法时，参数名称不会丢失

##### 5 SourceFile及SourceDebugExtension

SourceFile用于记录生成这个Class文件的源码文件名称

SourceDebugExtension用来储存一些额外的调试信息，如定位JSP报错的行号

##### 6 ConstantValue

用于类变量属性表，作用是通知虚拟机自动为静态变量赋值

对实例变量的赋值是在实例构造器`<init>()`方法中进行的

对于类变量，有两种方式
- 在类构造器`<cinit>()`方法中
- 使用`ConstantValue`属性

##### 7 InnerClass

用于Class文件属性表，用于记录内部类与宿主类之间的关联

##### 8 Deprecated及Synthetic属性

Deprecated用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用

Synthetic用来代表此字段或者方法并不是由Java源码直接产生的，而是由编译器自行添加的

##### 9 Signature

用以支持泛型。任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量或者参数化类型，则Signature会为它记录泛型签名信息

Java语言的泛型采用的是擦除法实现的伪泛型，字节码中所有的泛型信息编译在编译之后都通通被擦除掉

使用擦除法的好处是实现简单，坏处是运行期时无法像C#等真泛型语言那样，将泛型类型与普通类型同等看待，运行期无法通过反射获得泛型信息

##### 10 运行时的注解相关属性

RuntimeVisibleAnnotations等6个属性用于提供对注解的支持。例如，当我们使用反射API来获取、字段或者方法上的注解时，返回值就是通过RuntimeVisibleAnnotations这个属性取得的

### 6.4 字节码指令简介

Java虚拟机的指令由一个单字节长度的、代表着某种特定操作含义的数字以及跟随其后的零至多个代表此操作所需的参数构成

Java虚拟机大部分指令都不包括操作数，只有一个操作码，指令参数都存放在操作数栈中

字节码指令集执行速度很快，但是也有很多缺点
1. 由于限制了Java虚拟机操作码的长度为一个字节(0到255)，这意味着指令集的操作码总数不能超过256条
2. 且Class文件放弃了编译后代码的操作数长度对齐，会导致解释执行字节码时会损失一定的性能

如果不考虑异常处理的话，Java虚拟机的解释器模型可以使用下面这段伪代码作为最基本的执行模型来理解
````
do{
    自动计算PC寄存器的值+1
    根据PC寄存器指示的位置，从字节码流中取出操作码
    if(字节码存在操作数)从字节码流中取出操作数；
    执行操作码所定义的操作
}while(字节码流长度 > 0)
````

#### 6.4.1 字节码与数据类型

在Java虚拟机的指令集中，大多数指令都包含其操作所对应的数据类型信息。`iload`指令用于从局部变量表中加载`int`型的数据到操作数，而`fload`指令加载的则是fload类型的数据

#### 6.4.2 操作数栈

操作数栈主要用于配合指令集使用，java之所以不用再指令集中放入操作数，是因为当执行到某个指令时，它需要的操作数都预先被前面的指令放入到操作数栈中。

#### 6.4.3 加载和存储指令

用于将数据在栈帧中的局部变量表和操作数栈之间来回传输，例如：`iload`将一个局部变量加载到操作栈

#### 6.4.4 运算指令

算术指令用于对两个操作数栈上的值进行某种特定运算，并将结果重新存入到操作栈顶。例如：加法操作`iadd`

#### 6.4.5 类型转换指令

类型转换指令可以将两个不同的数值类型相互转换，这些转换操作一般用于实现用户代码的强制类型转换，例如：`i2b`、`i2c`等

#### 6.5.6 对象创建与访问指令

创建类实例的指令：new
访问实例字段的指令:getfield、putfield等

#### 6.5.7 操作数栈管理指令

Java虚拟机提供了一些用于直接操作操作数栈的指令，包括
- 将操作数栈的栈顶一个或两个元素出栈：`pop`、`pop2`
- 复制栈顶一个或两个数值并将复制值重新压入栈：`dup`、`dup2`
- 将栈最顶端的两个数值互换：`swap`

#### 6.5.8 控制转移指令

控制转移指令可以让Java虚拟机有条件或无条件地从指定的位置指令而不是控制转移指令的下一条指令继续执行程序，从概念模型上理解，可以认为控制转移指令就是在有条件或无条件地修改PC寄存器的值。

- 条件分支: `ifeq`
- 复合条件分支：`tableswitch`
- 无条件分支：`goto`

#### 6.5.9 方法调用和返回指令

如`invokevirtual`、`invokeinterface`等指令可用来调用方法

#### 6.5.10 异常处理指令

`athrow`指令可以用来显式的抛出异常

#### 6.5.11 同步指令

Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor）来支持的。
方法级的同步是隐式的，即无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池的方法表结构中的`ACC_SYNCHRONIZED`访问标志得知一个方法是否声明为同步方法。当方法调用时，调用指令将会检查方法的`ACC_SYNCHRONIZED`访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那么这个同步方法所持有的管程将在异常抛到同步方法之外时自动释放。

同步一段指令集序列通常是由Java语言中的`synchronized`语句块来表示的，Java虚拟机的指令集中有 `monitorenter`和`monitorexit`两条指令来支持`synchronized`关键字的语义，正确实现`synchronized`关键字需要Javac编译器与Java虚拟机两者共同协作支持

### 6.5 公有设计，私有实现

Class文件格式以及字节码指令集这些内容与硬件操作系统及具体的虚拟机实现之间是完全独立的，实现者可能更愿意把它们看做是程序在各种Java平台实现之间互相安全地交互的手段。

理解公有设计与私有实现之间的分界线是非常有必要的，Java虚拟机实现必须能够读取Class文件并精确实现包含在其中的Java虚拟机代码的语义。拿着Java虚拟机规范一成不变地逐字实现其中要求的内容当然是一种可行的途径，但一个优秀的虚拟机实现，在满足虚拟机规范的约柬下对具体实现做出修改和优化也是完全可行的，并且虚拟机规范中明确鼓励实现者这样做。只要优化后 Class文件依然可以被正确读取，并且包含在其中的语义能得到完整的保持，那实现者就可以选择任何方式去实现这些语义，虚拟机后台如何处理 Class文件完全是实现者自己的事情，只要它在外部接口上看起来与规范描述的一致即可。

### 6.6 Class文件结构的发展

Class文件结构自Java虚拟机规范第1版订立以来，已经有二十多年的历史。这十多年间， Java技术体系有了翻天覆地的改变， Class文件结构一直处于比较稳定的状态， Class文件的主体结构、字节码指令的语义和数量几乎没有出现过变动，所有对 Class文件格式的改进，都集中在向访问标志、属性表这些在设计上就可扩展的数据结构中添加内容。

Class文件格式所具备的平台中立（不依赖于特定硬件及操作系统）、紧凑、稳定和可扩展的特点，是Java技术体系实现平台无关、语言无关两项特性的重要支柱。
