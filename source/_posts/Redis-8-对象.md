---
title: '[Redis][8][对象]'
date: 2020-02-29 16:18:26
tags:
    - redis
categories:
    - redis
---
## 第 8 章 Redis对象

Redis基于C语言实现了一整套底层**数据结构**，用于Redis上层构件使用
- 简单动态字符串（SDS）
- 双端链表
- 跳跃表
- 字典
- 整数集合
- 压缩列表

然后Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个**对象系统**，这个系统包含**五种**类型的对象，每种对象都用到了至少一种我们前面所介绍的数据结构。
- 字符串对象
- 列表对象
- 哈希对象
- 集合对象
- 有序集合对象

### 8.1 对象的类型与编码

Redis**使用对象来表示数据库中的键和值**，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键，另一个对象用作键值对的值。

Redis中的每个对象都由一个`redisObject`结构表示，该结构中和保存数据有关的三个属性分别是`type`属性、 `encoding`属性和`ptr`属性：
````c
typedef struct redisObject {

    // 类型
    unsigned type:4;

    // 编码
    unsigned encoding:4;

    // 对象最后一次被访问的时间
    unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */

    // 引用计数
    int refcount;

    // 指向实际值的指针
    void *ptr;

} robj;
````
- 其中，为了节省内存，前三个属性采用了位域，如`unsign type:4`，指定了`type`属性使用前四个`bit`

下面将对上面代码的属性进行解读

#### 8.1.1 类型

对象的`type`属性记录了对象的类型，这个属性的值可以是下表列出的常量的其中一个。
![](Redis-8-对象\200229_0.png)

对于Redis数据库保存的键值对来说，键总是一个字符串对象，而值则可以是这五种对象的任意一种。并且，当我们称呼一个键为“列表键”时，我们指的是“这个数据库键所对应的值为列表对象”。

`TYPE`命令：当我们对一个数据库键执行`TYPE`命令时，命令返回的结果为数据库键对应的值对象的类型。例如，列表键将返回列表类型。

#### 8.1.2 编码

`encoding`属性记录了对象所使用的编码，也即是说这个对象使用了什么数据结构作为对象的底层实现。每种类型的对象都至少使用了两种不同的编码，下表列出了每种类型的对象可以使用的编码。

![](Redis-8-对象\200229_1.png)

使用`OBJECT ENCODING`命令可以查看一个数据库键的值对象的编码
````
redis> SET msg "hello, world"
OK
redis> OBJECT ENCODING msg
"embstr"
````

通过`encoding`属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，极大地提升了Redis的灵活性和效率，因为Redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率。

### 8.2 字符串对象

#### 8.2.1 字符串对象的编码

字符串对象的编码可以是`int`、`raw`或者 `embstr`
- `int`
    - 如果一个字符串对象保存的是整数值，并且这个整数值可以`long`类型来表示
    - 那么字符串对象会直接将整数值保存在字符串对象结构的`ptr`属性里面（将`void*`转换成`1ong`）
    - 并将字符串对象的编码设置为`int`。
    - 例如下图
    ![](Redis-8-对象\200229_3.png)

- `raw`
    - 如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于32字节
    - 那么字符串对象将使用一个简单动态字符串（`SDS`）来保存这个字符串值
    - 并将对象的编码设置为`raw`
    - 例如下图
    ![](Redis-8-对象\200229_2.png)

- `embstr`
    - 如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于32字节
    - 那么字符串对象将使用`embstr`编码的方式来保存这个字符串值
    - 这种编码和`raw`编码一样，都使用`redisObject`结构和`sdshdr`结构来表示字符串对象
    - `embstr`编码只调用一次内存分配函数分配一块连续的空间，空间中依次包含 `redisObject`和`sdshdr`两个结构，
    - 例如下图
    ![](Redis-8-对象\200229_4.png)

使用`embstr`编码的好处如下
- 将创建字符串对象所需的内存分配次数从`raw`编码的两次降低为一次
- 释放`embstr`编码的字符串对象只需要调用一次内存释放函数，而释放`raw`编码的字符串对象需要调用两次内存释放函数
- 所有数据都保存在一块连续的内存里面

此外，**浮点数**在Redis中也是作为字符串值来存储的

#### 8.2.1 字符串对象编码转换

`int`到`raw`的转换
- 对于`int`编码的字符串对象来说，如果我们向对象执行了一些命令，使得这个对象保存的不再是整数值，而是一个字符串值
- 那么字符串对象的编码将从`int`变为`raw`。

`embstr`到`raw`的转换
- Redis没有为`embstr`编码的字符串对象编写任何相应的修改程序，所以`embstr`编码的字符串对象实际上是**只读的**
- `embstr`编码的字符串对象在**执行修改命令**之后，总会变成一个`raw`编码的字符串对象。

#### 8.2.2 字符串命令的实现

![](Redis-8-对象\200229_5.png)

### 8.3 列表对象

#### 8.3.1 列表对象的编码

列表对象的编码可以是`ziplist`或者`linkedlist`

`ziplist`
- `ziplist`编码的列表对象使用压缩列表作为底层实现，每个压缩列表节点保存了一个列表元素
- 例如我们执行如下命令，创建一个包括三个元素的`numbers`列表键
    ````sh
    redis> RPUSH numbers 1 "three" 5
    (integer) 3
    ````
- 结果如下图
![](Redis-8-对象\200229_6.png)

`linkedlist`
- `linkedlist`编码的列表对象使用双端链表作为底层实现，每个链表节点都保存了一个**字符串对象**，而每个**字符串对象**都保存了一个**列表元素**
- 还是上面的`numbers`列表，在`linkedlist`以下图结构存储
![](Redis-8-对象\200229_7.png)

#### 8.3.2 列表对象编码转换

当列表对象可以**同时满足**以下两个条件时，列表对象使用`zip1ist`编码：
- 列表对象保存的所有**字符串元素的长度**都小于64字节
- 列表对象保存的**元素数量**小于512个

**不能**满足上述两个条件的列表对象需要使用`linkedlist`编码。

当使用`ziplist`编码所需的两个条件的任意一个**不能**被满足时，对象的**编码转换**操作就会被执行，原本保存在**压缩列表**里的所有列表元素都会被**转移**并保存到**双端链表**里面，对象的**编码**也会从`zip1ist`变为`linkedlist`

#### 8.3.3 列表命令的实现

![](Redis-8-对象\200229_8.png)

### 8.4 哈希对象

#### 8.4.1 哈希对象的编码

哈希对象的**编码**可以是`ziplist`或者`hashtable`

`ziplist`
- `ziplist`编码的哈希对象使用**压缩列表**作为**底层实现**
- 每当有键值对要**新加入**到哈希对象时
    - 程序会先将保存了**键**的压缩列表节点推入到压缩列表**表尾**
    - 然后再将保存了**值**的压缩列表节点推入到压缩列表**表尾**
- 保存了**同一键值对**的两个节点总是**紧挨**在一起
- **先添加**到哈希对象中的键值对会被放在压缩列表的**表头**方向，而**后添加**到哈希对象中的键值对会被放在压缩列表的**表尾**方向。
- 例如下图
![](Redis-8-对象\200229_9.png)

`hashtable`
- `hashtable`编码的哈希对象使用**字典**作为底层实现
- 哈希对象中的每个键值对都使用一个**字典键值对**来保存
    - 字典的每个**键**都是一个**字符串对象**，对象中保存了键值对的键
    - 字典的每个**值**都是一个**字符串对象**，对象中保存了键值对的值。
- 例如下图
![](Redis-8-对象\200229_10.png)

#### 8.4.2 哈希对象编码转换

当哈希对象可以**同时**满足以下两个条件时，哈希对象使用`ziplist`编码：
- 哈希对象保存的所有键值对的**键和值**的**字符串长度**都小于64字节
- 哈希对象保存的**键值对数量**小于512个

**不能**满足这两个条件的哈希对象需要使用`hashtable`编码。

当使用`ziplist`编码所需的两个条件的**任意**一个**不能**被满足时，对象的**编码转换**操作就会被执行，原本保存在**压缩列表**里的所有键值对都会被**转移**并保存到**字典**里面，对象的**编码**也会从`zip1ist`变为`hashtable`

#### 8.4.2 哈希命令的实现

![](Redis-8-对象\200229_11.png)

### 8.5 集合对象

#### 8.5.1 集合对象的编码

集合对象的**编码**可以是`intset`或者`hashtable`。

`intset`
- `intset`编码的集合对象使用**整数集合**作为底层实现，集合对象包含的所有元素都被保存在整数集合里面
- 例如下图
![](Redis-8-对象\200229_12.png)

`hashtable`
- `hashtable`编码的集合对象使用**字典**作为底层实现
- 字典的每个**键**都是一个**字符串对象**，每个字符串对象包含了一个集合元素，而字典的**值**则全部被设置为**NULL**。

#### 8.5.2 集合对象编码转换

当集合对象可以**同时满足**以下两个条件时，对象使用`intset`编码
- 集合对象保存的所有元素都是**整数值**
- 集合对象保存的**元素数量**不超过512个

**不能**满足这两个条件的集合对象需要使用 `hashtable`编码。

#### 8.5.3 集合命令的实现

![](Redis-8-对象\200229_13.png)
![](Redis-8-对象\200229_14.png)

### 8.6 有序集合对象

#### 8.6.1 有序集合对象的编码

有序集合的**编码**可以是`ziplist`或者`skiplist`

`ziplist`
- `zip1ist`编码的压缩列表对象使用**压缩列表**作为底层实现
- 每个集合元素使用**两个紧挨**在一起的压缩列表节点来**保存**，第一个节点保存元素的**成员**（member），而第二个元素则保存元素的**分值**（score，作为排序的依据）
- 压缩列表内的集合元素按分值**从小到大**进行**排序**
- 例如下图
![](Redis-8-对象\200229_15.png)

`skiplist`
- `skiplist`编码的有序集合对象使用`zset`结构作为底层实现，一个`zset`结构**同时**包含一个**字典**和一个**跳跃表**
- **跳跃表**按分值**从小到大**保存了所有集合元素，每个跳跃表节点都保存了一个集合元素：跳跃表节点的`object`属性保存了元素的**成员**，而跳跃表节点的`score`属性则保存了元素的**分值**。
- 字典为有序集合创建了一个**从成员到分值的映射**，字典中的每个键值对都保存了一个集合元素：
    - 字典的**键**保存了元素的**成员**
    - 而字典的**值**则保存了元素的**分值**
    - 通过这个字典，程序可以用 $O(1)$ 复杂度**查找给定成员的分值**
- 有序集合每个元素的**成员**都是一个**字符串对象**，而每个元素的**分值**都是一个`double`类型的**浮点数**
- 这两种数据结构都会通过**指针共享相同元素**的成员和分值，所以同时使用跳跃表和字典来保存集合元素**不会产生重复**成员或者分值
- 例如下图
![](Redis-8-对象\200229_16.png)

#### 8.6.2 有序集合对象编码转换

当有序集合对象可以**同时**满足以下两个条件时，对象使用`ziplist`编码
- 有序集合保存的**元素数量**小于128个
- 有序集合保存的所有**元素成员的长度**都小于64字节

**不能**满足以上两个条件的有序集合对象将使用`skiplist`编码

#### 8.6.2 有序集合命令的实现

![](Redis-8-对象\200229_17.png)

### 8.7 类型检查与命令多态

Redis中用于操作键的命令可以分为两种
1. 其中一种命令可以对**任何类型的键**使用，例如`DEL`命令、`EXPIRE`命令、`RENAME`命令、`TYPE`命令等，这种命令背后的实现机制是**命令多态**
2. 另一种命令只能应用于**特定类型**的键，例如`SET`、`GET`、`APPEND`、`STRLEN`等命令只能对字符串键执行，这种命令的实现需要经过**类型检查**

#### 8.7.1 类型检查的实现

在执行一个**类型特定的命令**之前，Redis会先检查**输入键**的**类型**是否正确，然后再决定是否执行给定的命令。

类型特定命令所进行的**类型检查**是通过`redisObject`结构的`type`属性来实现的
- 在执行一个类型特定命令之前，服务器会先检查输入数据库键的**值对象**是否为执行命令所需的类型
- 如果是的话，服务器就对键执行指定的命令；否则，服务器将**拒绝**执行命令，并向客户端返回一个**类型错误**。

例如下图
![](Redis-8-对象\200229_18.png)

#### 8.7.1 多态命令的实现

Redis除了会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据**值对象**的**编码**方式，选择正确的命令**实现代码**来执行命令。

如下图
![](Redis-8-对象\200229_19.png)

### 8.8 内存回收

因为C语言并不具备自动内存回收功能，所以Redis在自己的对象系统中构建了一个**引用计数技术**实现的**内存回收**机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。

每个对象的引用计数信息由`redisObject`结构的 `refCount`属性记录（可以查看本章第一节）

对象的**引用计数信息**会随着对象的**使用状态**而不断变化：
- 在**创建**一个新对象时，引用计数的值会被**初始化**为1
- 当对象被一个**新程序**使用时，它的引用计数值会被**增一**
- 当对象**不再**被一个程序使用时，它的引用计数值会被**减一**
- 当对象的引用计数值**变为0**时，对象所占用的内存会被**释放**

### 8.9 对象共享

除了用于实现引用计数内存回收机制之外，对象的**引用计数**属性还带有**对象共享**的作用。

在Redis中，让多个键共享同一个值对象需要执行以下两个步骤：
1. 将数据库键的**值指针**指向一个现有的**值对象**；
2. 将被共享的**值对象**的**引用计数增一**

例如下图
![](Redis-8-对象\200229_20.png)

Redis只**对包含整数值的字符串对象**进行**共享**，也就是`type`为`StringObject`，`encoding`为`int`。

目前来说， Redis会在**初始化服务器**时，**创建**一万个**字符串对象**，这些对象包含了从0到9999的所有整数值，当服务器需要用到值为0到9999的字符串对象时，服务器就会使用这些共享对象，而不是新创建对象。

### 8.10 对象的空转时长

`redisObject`结构包含的最后一个属性为`lru`属性，该属性记录了对象**最后一次被命令程序访问的时间**

`OBJECT IDLETIME`命令可以打印出给定键的**空转时长**，这一空转时长就是通过将当前时间减去键的值对象的lru时间计算得出的：
````sh
SET msg "hello, world"
OBJECT IDLETIME msg
````

### 8.11 本章重点

- Redis数据库中的每个**键值对**的键和值都是一个**对象**。
- Redis共有字符串、列表、哈希、集合、有序集合五种类型的**对象**，每种类型的对象至少都有两种或以上的**编码方式**，不同的编码可以在不同的使用场景上优化对象的使用效率。
- 服务器在执行某些命令之前，会先**检查**给定键的**类型**能否执行指定的命令。
- Redis的对象系统带有**引用计数**实现的**内存回收**机制，当一个对象不再被使用时，该对象所占用的内存就会被自动释放
- Redis会**共享**值为0到9999的字符串**对象**
- 对象会记录自己的最后一次被访问的时间，这个时间可以用于计算对象的**空转时间**。
