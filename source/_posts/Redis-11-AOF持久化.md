---
title: '[Redis][11][AOF持久化]'
date: 2020-03-04 13:46:38
tags:
    - redis
    - aof
categories:
    - redis
---
## 第 11 章 AOF持久化

AOF持久化是通过**保存**Redis服务器所执行的**写命令**来记录数据库状态的。服务器在**启动**时，可以通过**载入和执行**AOF文件中保存的**命**令来**还原**服务器关闭之前的数据库状态。

### 11.1 AOF持久化的实现

AOF持久化功能的实现可以分为**命令追加**、**文件写入**、**文件同步**三个步骤。

#### 11.1.1 命令追加

当AOF持久化功能处于打开状态时，服务器在执行完一个**写命令**之后，会以协议格式将被执行的写命令**追加**到服务器状态的`aof_buf`**缓冲区的末尾**

#### 11.1.2 AOF文件的写入与同步

Redis的服务器进程就是一个**事件循环**，这个循环中的**文件事件**负责接收客户端的命令请求，以及向客户端发送命令回复，而**时间事件**则负责执行像`serveCron`函数这样需要定时运行的函数。下一章将解释这些内容

因为服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到`aof_buf`缓冲区里面，所以在服务器**每次结束一个事件循环**之前，它都会调用`flushAppendonlyFile`函数，考虑**是否**需要将`aof_buf`缓冲区中的内容**写入和保存到AOF文件**里面

伪代码大概如下
````py
def eventLoop():
    while True:

        # 处理文件请求，处理请求时可能会把新内容追加到aof_buf缓冲区
        processFileEvents()

        # 处理时间请求
        processTimeEvents()

        # 考虑是否将aof_buf中的内容写入和保存到AOF文件中
        flushAppendOnlyFile()
````

`flushAppendOnlyFile()`函数的策略由服务器配置的`appendfsync`选项的值来决定

|配置|行为|
|--|--|
|always|将aof_buf缓冲区中的所有内容**写入**并**同**步到AOF文件|
|everysec|将aof_buf缓冲区中的所有内容**写入**到AOF文件，如果上次同步AOF文件的时间距离现在**超过了1秒**，那么再次对AOF文件进行**同步**|
|no|将aof_buf缓冲区中的所有内容**写入**到AOF文件，但并不对AOF文件进行同步，**同步由系统决定**|

下面解释什么是文件的**写入**和**同步**

- 为了提高文件的写入效率，在现代操作系统中，当用户调用`write`函数，将一些数据写入到文件的时候，操作系统通常会将写入数据**暂时保存**在一个内存缓冲区里面，
- 等到缓冲区的空间被填满、或者超过了指定的时限之后，才真正地将缓冲区中的数据**写入到磁盘**里面。
- 用户将数据写入到内存缓冲区的过程叫做**写入**
- 系统将内存缓冲区的内容写入到磁盘对应的文件的过程叫做**同步**

### 11.2 AOF文件的载入与数据还原

服务器只要**读入并重新执行**一遍AOF文件里面保存的**写命令**，就可以**还原**服务器关闭之前的数据库状态。

Redis读取AOF文件并还原数据库状态的步骤如下
1. **创建**一个不带网络连接的**伪客户端**，因为Redis的命令只能在客户端上下文中执行
2. 从AOF文件中**分析并读取**出一条写命令。
3. 使用**伪客户端执行**被读出的写命令。
4. 一直执行步骤2和步骤3，直到AOF文件中的所有写命令都被处理完毕为止。

流程图如下

![](Redis-11-AOF持久化\200303_1.png)

### 11.3 AOF重写

因为AOF持久化是通过保存被执行的写命令来记录数据库状态的，所以随着服务器**运行时间**的流逝，AOF文件中的**内容**会越来越**多**。

为了**解决AOF文件体积膨胀**的问题， Redis提供了**AOF文件重写**功能。通过该功能，Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个AOF文件所保存的**数据库状态相同**，但新文件中不包括冗余指令

#### 11.3.1 AOF文件重写的实现

其实AOF文件的重写策略十分简单，它并**不查看旧文件**的任何内容。它直接**根据当前的数据库状态**生成一份新的AOF文件。

例如，假设我们对一个`list`进行了如下操作
````sh
RPUSH list "A" "B" "C"
RPUSH list "C"
RPUSH list "D" "E"
LPOP list
LPOP list
RPUSH list "F" "G"
````

那么其实，在此时的数据库状态中，`list`键的值只有`{"C", "D", "E", "F", "G"}`而已

在执行AOF重写时，Redis直接查看`list`键的当前值，然后将当前的这五个值用同一条`RPUSH`命令存储，仅此而已
````sh
RPUSH list "C" "D" "E" "F" "G"
````

假设我们要对下面这个数据库状态进行AOF重写
![](Redis-11-AOF持久化\200303_2.png)

重写后的AOF文件包含如下命令
````sh
SELECT 0

RPUSH alphabet "a" "b" "c"

EXPIREAT alphabet 1385877600000

HSET book "name" "Redisin Action" "author" "Josiah L.Carlson"

EXPIREAT book 1385877600000

SET message "hello, world"
````

#### 11.3.2 AOF后台重写

Redis**不希望**AOF**重写**造成服务器**无法处理请求**，所以Redis决定将AOF重写程序放到**子进**程里执行，这样子进程进行AOF重写期间，服务器进程（父进程）可以继续处理命令请求。

不过，子进程在进行AOF重写期间，服务器进程还需要继续处理命令请求，而**新的命令**可能会对**现有的数据库状态**进行**修改**，从而使得服务器当前的数据库状态和重写后的AOF文件所保存的数据库状态不一致。例子如下表所示

![](Redis-11-AOF持久化\200303_3.png)

为了解决这种数据不一致问题，Redis服务器设置了一个**AOF重写缓冲区**，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区，如下图

![](Redis-11-AOF持久化\200303_4.png)

这样，当子进程完成AOF重写工作后，它会给父进程**发送一个信号**，父进程接到这个信号后，会**阻塞所有请求**，并执行如下操作
1. 将**AOF重写缓冲区**中的内容**写入到AOF文件**中，这时新AOF文件所保存的数据库状态将与服务器状态完全相同
2. 对新的AOF文件进行**改名**，原子的**覆盖**现有的AOF文件，完成两个文件的替换

### 11.4 重点回顾

略
