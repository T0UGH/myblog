---
title: '[数据结构考研][1][绪论]'
date: 2019-12-25 12:07:28
tags:
    - 数据结构
categories:
    - 数据结构
---
## 第 1 章 绪论

### 1.1 数据结构的基本概念

### 1.1.1 基本概念和术语

##### 1 数据

数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合

##### 2 数据元素

数据元素是数据的基本单位，通常作为一个整体进行考虑和处理

一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位

例如，学生记录就是一个数据元素，它由学号、姓名和性别等数据项组成

##### 3 数据对象

数据对象是具有相同性质的数据元素的集合，是数据的一个子集。

例如，整数数据对象是集合`N={0, 1, 2}`

##### 4 数据类型

数据类型是一个值的集合和定义在此集合上的一组操作的总称
1. 原子类型: 其值不可再分的数据类型
2. 结构类型: 其值可以再分解为若干成分的数据类型
3. 抽象数据类型: 抽象数据组织及与之相关的操作

##### 5 抽象数据类型

抽象数据类型(`ADT`)是指一个数据模型及定义在该模型上的一组操作

抽象数据类型的定义仅取决于它的一组逻辑特性，而与其再计算机内部如何表示和实现无关，即无论其内部结构如何变化，只要它的数学特性不变，都不影响其外部的使用

通常用数据对象、数据关系和基本操作集这样的三元组来表示抽象数据类型

##### 6 数据结构

数据元素不是孤立存在的，它们之间存在某种关系

这种数据元素相互之间的关系称为结构

数据结构是相互之间存在一种或多种特定关系的数据元素的集合

数据结构包括三方面的内容：逻辑结构、存储结构和数据的运算

数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构

#### 1.1.2 数据结构三要素

##### 1 数据的逻辑结构

逻辑结构是指数据元素之间的逻辑关系。它与数据的存储无关，独立于计算机

1. 集合: 结构中的数据元素之间除"同属于一个集合"的关系外，别无其他关系
2. 线性结构: 结构中的数据元素之间只存在一对一的关系
3. 树形结构: 结构中的数据元素之间存在一对多的关系
4. 涂装结构或网状结构: 结构中的数据元素之间存在多对多的关系

````dot
digraph demo{
    数据的逻辑结构->线性结构[dir=none];
    数据的逻辑结构->非线性结构[dir=none];
    线性结构->一般线性表[dir=none];
    线性结构->受限线性表[dir=none];
    线性结构->线性表推广[dir=none];
    受限线性表->栈[dir=none];
    受限线性表->队列[dir=none];
    受限线性表->串[dir=none];
    线性表推广->数组[dir=none];
    线性表推广->广义表[dir=none];
    非线性结构->集合[dir=none];
    非线性结构->树形结构[dir=none];
    非线性结构->图状结构[dir=none];
    树形结构->一般树[dir=none];
    树形结构->二叉树[dir=none];
    图状结构->有向图[dir=none];
    图状结构->无向图[dir=none];
}
````

##### 2 数据的存储结构

存储结构是指数据结构在计算机中的表示(也叫做映像)，也称物理结构

数据的存储结构是用计算机语言实现的逻辑结构，它依赖于计算机语言

数据的存储结构主要由顺序存储、链式存储、索引存储和散列存储
1. 顺序存储
    - 把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现
    - 其优点是可以实现随机存取，每个元素占用最少的存储空间；
    - 缺点是只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片
2. 链式存储
    - 不要求逻辑上相邻的元素在物理位置上也相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系
    - 优点是不会出现碎片现象，能充分利用所有存储结构
    - 缺点是每个元素因存储指针而占用额外的存储空间，且只能实现顺序存取
3. 索引存储
    - 在存储元素信息的同时，还建立附加的索引表
    - 索引表中的每一项称为索引项，索引项的一般形式是`关键字+地址`
    - 其优点是索引速度快
    - 缺点是增加附加的索引表后会占用较多的存储空间
    - 另外，在郑家和删除数据时要修改索引表，因而会花费较多时间
4. 散列存储
    - 根据元素的关键字直接计算出该元素的存储地址，又称`hash`存储
    - 优点时检索、增加和删除节点的操作都很快
    - 缺点是若散列函数不好，则可能出现元素存储单元的冲突，而解决冲突会增加时间和空间开销

##### 3 数据的运算

施加在数据上的运算包括运算的定义和实现

运算的定义是针对逻辑结构的，指出运算的功能

运算的实现是针对存储结构的，指出运算的具体操作步骤

### 1.2 算法和算法评价

#### 1.2.1 算法的基本概念

算法是对特定问题求解步骤的一种描述，它是指令的优先序列，其中的每条指令表示一个或多个操作

算法的5个重要特性
1. 有穷性: 一个算法必须总是在执行有穷步之后结束，且每一步都可在有穷的时间内完成
2. 确定性: 算法中每条指令必须由确切的含义，读者理解时不会产生二义性，即对于相同的输入只能得到相同的输出
3. 可行性: 一个算法是可行的，即算法中描述的操作都是可以通过已经实现的基本算法执行有限次来实现的
4. 输入: 一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合
5. 输出: 一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量

通常设计一个好的算法应考虑达成如下目标
1. 正确性: 算法应能够正确地解决求解问题
2. 可读性: 算法应具有良好的可读性，以帮助人们理解
3. 健壮性: 输入非法数据时，算法应能适当做出反应或进行处理，而不会产生莫名奇妙的输出结果
4. 效率和低存储量需求: 效率是指算法执行的时间，存储量需求是指算法执行过程中所需要的最大存储空间，这两者都与问题的规模有关

#### 1.2.2 算法效率的度量

算法效率的度量是通过时间复杂度和空间复杂度来描述的

##### 1 时间复杂度

频度: 一个语句的频度是指该语句在算法中被重复执行的次数

$T(n)$: 算法中所有语句的频度之和记为$T(n)$，它是该算法问题规模$n$的函数

$T(n)$ 的数量级:若$T(n)=N^2 + N + 1$，数量级为$N^2$，时间复杂度主要分析$T(n)$的数量级，算法中基本运算(最深层循环内的语句)的频度$f(n)$与$T(n)$同数量级

通常采用算法中基本运算的频度 $f(n)$ 来分析算法的时间复杂度。因此，算法的时间复杂度记为 $T(n)=O(f(n))$

算法的时间复杂度不仅依赖于问题的规模 $n$，也取决于待输入数据的性质(如输入数据元素的初始状态)

1. 最坏时间复杂度: 在最坏情况下，算法的时间复杂度
2. 平均时间复杂度: 所有可能输入实例在等概率出现的情况下，算法的期望运行时间
3. 最好时间复杂度: 在最好情况下，算法的时间复杂度

一般总是考虑在最坏情况下的时间复杂度，以确保算法的运行时间不会比它长

在分析一个程序的时间复杂性时，有以下两条规则
1. 加法规则
$$T(n) = T_1(n) + T_2(n) = O(f(n)) + O(g(n)) = O(max(f(n), g(n))$$
2. 乘法规则
$$T(n) = T_1(n) \times T_2(n) = O(f(n)) * O(g(n)) = O(f(n) \times g(n))$$

常见的渐进时间复杂度为
$$O(1) < O(log_2n) < O(n) < O(nlog_2n) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)$$

时间复杂度的两种解法
1. 循环主体中的变量参与循环条件的判断
    - 此类题应找出主体语句中与$T(n)$成正比的循环变量，将之代入条件中进行计算
    - 例如
        ````c
        int i = 1;
        while(i <= n)
            i *= 2;
        ````
        i乘以2的次数正是主题语句的执行次数，因此有$2^t \le n$，取对数后得$t \le log_2n$
2. 循环主题中的变量与循环条件无关
    - 此类题可采用数学归纳法或直接累计循环次数。多层循环时从内到外分析，忽略单步语句、条件判断语句，只关注主体语句的执行次数。此类问题又可分为递归程序和非递归程序
    - 若用递归程序，一般用公式进行递推，例如: $T(n) = 1 + T(n - 1) = 1 + 1 + T(n - 2) = n - 1 + T(1)$
    - 如果非递归程序，直接累计次数即可

##### 2 空间复杂度

算法的空间复杂度$S(N)$定义为该算法所耗费的存储空间，它是问题规模$n$的函数。渐进空间复杂度也常简称为空间复杂度，记为$S(n)=O(g(n))$

一个上机程序出需要存储空间来存放本身所用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储为实现计算所需要的一些信息的辅助空间，若输入数据所占空间只取决于问题本身而与算法无关，只需分析除输入和程序外的额外空间

算法*原地工作*是指算法所需的辅助空间为常量，即$O(1)$