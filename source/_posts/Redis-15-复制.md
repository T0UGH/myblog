---
title: '[Redis][15][复制]'
date: 2020-03-05 20:56:33
tags:
    - redis
categories:
    - redis
---
## 第 15 章 复制

在Redis中，用户可以通过执行`SLAVEOF`命令或者设置`slaveof`选项，让一个服务器去复制另一个服务器，我们称呼被复制的服务器为**主服务器**(master)，而对主服务器进行复制的服务器叫做**从服务器**（slave）

例如下面的命令
````sh
127.0.0.1:12345>SLAVEOF 127.0.0.1:6379
OK
````
然后12345就成了6379的从服务器

进行复制的主从服务器双方的数据库将保存相同的数据，这称为数据库状态一致

### 15.1 旧版复制功能的实现

Redis的**复制**功能分为**同步**（sync）和**命令传播**（command propagate）两个操作

- **同步**操作用于将**从服务器**的**数据库状态****更新**至**主服务器当前所处的数据库状态**。
- **命令传播**操作则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现**不一致时**，让主从服务器的数据库**重新回到一致状态**。

#### 15.1.1 同步

当客户端发送`SLAVEOF`命令给从服务器时，要求从服务器复制主服务器，从服务器会首先执行**同步**操作。

从服务器对主服务器的**同步操作**需要通过向主服务器发送**SYNC命令**来完成
1. **从**服务器向**主**服务器发送**SYNC命令**
2. 收到SYNC命令的**主服务器**执行**BGSAVE**命令，在后台生成一个RDB文件，并使用一个**缓冲区记录**从现在开始执行的所有**写命令**。
3. 当主服务器的BGSAVE命令**执行完毕**时，主服务器会将BGSAVE命令生成的**RDB文件发送**给从服务器，从服务器接收并**载入**这个**RDB文件**，将自己的数据库状态**更新至主服务器执行BGSAVE命令时的数据库状态**。
4. 主服务器将记录在**缓冲区**里面的所有**写命令**发送给从服务器，从服务器执行这些写命令，将自己的数据库状态**更新至主服务器数据库当前所处的状态**。

步骤如下图所示
![](Redis-15-复制\200305_7.png)

下表是一个主从服务器进行同步的例子
![](Redis-15-复制\200305_8.png)

#### 15.1.2 命令传播

每当**主服务器**执行客户端发送的**写命令**时，主服务器的数据库就有可能会被修改，并导致主从服务器状态**不一致**。

为了让主从服务器**再次一致**，主服务器需要对从服务器执行**命令传播**操作
- 主服务器会将自己执行的写命令，也即是**造成**主从服务器**不一致**的那条**写命令**，**发送给从服务器**执行
- 当从服务器**执行了相同的写命令**之后，主从服务器将**再次回到一致**状态

例如下面几张图
![](Redis-15-复制\200305_9.png)
![](Redis-15-复制\200305_10.png)
![](Redis-15-复制\200305_11.png)

### 15.2 旧版复制功能的缺陷

在旧版，复制主要应用于以下两种场景
1. **初次复制**：从服务器之前没有复制过主服务器
2. **断线后重复制**：处于命令传播阶段的主从服务器因为网络问题而中断，但从服务器之后重连了主服务器。这时，发生了数据不一致。Redis旧版中面对这个情况，直接执行复制操作，将主服务器当前状态打包为RDB传送给从服务器

例子如下表
![](Redis-15-复制\200305_12.png)

**问题的关键**就在于：断线之后，从服务器只不过少执行了几条写指令而已。为了恢复一致性，却大动干戈地**重新执行了全部的复制操作**，这会浪费大量资源。

### 15.3 新版复制功能的实现

为了解决旧版复制功能在处理断线重复制情况时的低效问题，Redis从2.8版本开始，使用`PSYNC`命令代替`SYNC`命令来执行复制时的同步操作

PSYNC命令具有完整重同步和部分重同步两种模式
- **完整重同步**类似于`SYNC`命令，它会将主服务器状态打包为RDB发送
- **部分重同步**则用于**断线重连**的情况。主服务器可以将主从服务器连接**断开期间执行的写命令**发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态。

上一节的例子在新版会如下表方式执行
![](Redis-15-复制\200305_13.png)

下图展示了主从服务器执行部分重同步时的通信过程
![](Redis-15-复制\200305_14.png)

### 15.4 部分重同步的实现

部分重同步的功能由下面三部分组成
- 主服务器的**复制偏移量**和从服务器的复制偏移量
- 主服务器的**复制积压缓冲区**
- 服务器的**运行ID**

#### 15.4.1 复制偏移量

主服务器和从服务器会**分别**维护一个**复制偏移量**
- 主服务器每次向从服务器**传播N个字节**的数据时，就将自己的复制偏移量的值**加上N**
- 从服务器每次**收到**主服务器传播来的**N个字节**的数据时，就将自己的复制偏移量的值**加上N**

下面举例说明

刚开始主从服务器有相同的偏移量`10086`
![](Redis-15-复制\200305_15.png)

此时，主服务器传播长度为33字节的数据，假如所有从服务器正常，如下图
![](Redis-15-复制\200305_16.png)

假如有一个从服务器掉线
![](Redis-15-复制\200305_17.png)

从上例，通过对比主从服务器的复制偏移量，程序可以很容易的直到主从服务器是否处于一致状态

#### 15.4.2 复制积压缓冲区

复制积压缓冲区是由主服务器维护的一个固定长度先进先出队列，默认大小为1MB。

当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区里面，如下图
![](Redis-15-复制\200305_18.png)

复制积压缓冲区会保存最近传播的写命令，且缓冲区中的**每个字节**都**对应**一个**复制偏移量**，例如下图
![](Redis-15-复制\200305_19.png)

当从服务器重新连上主服务器时，从服务器会通过`PSYNC`命令将自己的复制偏移量`offset`发送给主服务器，主服务器会**根据**这个**复制偏移量**来**决定**对从服务器执行**何种同步**
- 如果`offset`偏移量之后的数据**仍然存在**于**复制积压缓冲区**里面，那么主服务器将对从服务器执行**部分重同步**操作。

- **否则**主服务器将对从服务器执行**完整重同步**操作。

回到上面的例子，当掉线的从服务器上线后，发送`PSYNC`命令并附上自己的复制偏移量`10086`，然后主服务器发现10086之后的字节都在缓冲区，直接取出并发送给从服务器
![](Redis-15-复制\200305_20.png)


#### 15.4.3 服务器运行ID

每个Redis服务器，无论主从，都拥有一个自己的运行ID，它在服务器启动时自动生成，由40个随机的十六进制字符组成

当从服务器对主服务器进行初次复制时，主服务器会将自己的运行ID传送给从服务器保存。

当从服务器掉线重连时，会发送这个ID。若ID相同，说明掉线之前的主服务器就是这个主服务器，则尝试执行部分重同步；若不相同，则执行完整重同步

### 15.5 PSYNC命令

本节将详细介绍`PSYNC`命令的完整细节

`PSYNC`命令的调用方法有两种
- 如果从服务器以前没有复制过任何主服务器，那么从服务器在开始一次新的复制时将向主服务器发送`PSYNC ? -1`命令，主动请求主服务器进行完整重同步
- 如果从服务器已经复制过某个主服务器，那么从服务器在开始一次新的复制时将向主服务器发送`PSYNC <runid> <offset>`命令：其中`runid`是上一次复制的主服务器的运行ID，而`offset`则是从服务器当前的复制偏移量

根据情况，接收到`PSYNC`命令的主服务器会向从服务器返回以下三种回复的其中一种：
- 如果主服务器返回`+FULLRESYNC <runid> <offset>`回复，那么表示主服务器将与从服务器执行完整重同步操作：其中`runid`是这个主服务器的运行ID，从服务器会将这个ID保存起来，在下一次发送`PSYNC`命令时使用；而`offset`则是主服务器当前的复制偏移量，从服务器会将这个值作为自己的初始化偏移量。
- 如果主服务器返回`+CONTINUE`回复，那么表示主服务器将与从服务器执行部分重同步操作，从服务器只要等着主服务器将自己缺少的那部分数据发送过来就可以了。
- 如果主服务器返回`-ERR`回复，那么表示主服务器的版本过低，它识别不了`PSYNC`命令，从服务器将向主服务器发送`SYNC`命令，并与主服务器执行完整同步操作。

流程图如下
![](Redis-15-复制\200305_21.png)

### 15.6 复制的实现

本节将按顺序介绍服务器收到客户端发送的`SLAVEOF`命令后的全部操作

#### 15.6.1 设置主服务器的地址和端口

从服务器首先要做的就是将客户端给定的主服务器IP地址以及端口保存到服务器状态的`masterhost`属性和`masterport`属性里面

`SLAVEOF`命令是一个异步命令，在完成`masterhost`属性和`masterport`属性的设置工作之后，从服务器将向发送`SLAVEOF`命令的客户端返回`OK`，表示复制指令已经被接收，而实际的复制工作将在`OK`返回之后才真正开始执行。

#### 15.6.2 建立套接字连接

在`SLAVEOF`命令执行之后，从服务器将根据命令所设置的IP地址和端口，创建连向主服务器的套接字连接

然后，从服务器将为这个套接字关联一个专门用于处理复制工作的文件事件处理器，这个处理器将负责执行后续的复制工作，比如接收RDB文件，以及接收主服务器传播来的写命令，诸如此类。

而主服务器在接受从服务器的套接字连接之后，将为该套接字创建相应的客户端状态，并将从服务器看作是一个连接到主服务器的客户端来对待，

#### 15.6.3 发送PING命令

从服务器成为主服务器的客户端之后，做的第一件事就是向主服务器发送一个PING命令，它有两个作用
- 通过发送PING命令可以检查套接字的读写状态是否正常。
- 通过发送PING命令可以检查主服务器能否正常处理命令请求。

从服务器发送PING命令后会遇到如下三种情况
- 如果主服务器向从服务器返回了一个命令回复，但从服务器却不能在规定的时限内读取出命令回复的内容，那么表示主从服务器之间的网络连接状态不佳。这时，从服务器断开并重新创建连向主服务器的套接字
- 如果主服务器向从服务器返回一个错误，那么表示主服务器暂时没办法处理从服务器的命令请求，不能继续执行复制工作的后续步骤。这时，从服务器断开并重新创建连向主服务器的套接字
- 如果从服务器读取到`PONG`回复，那么表示连接正常，在这种情况下从服务器可以继续执行复制工作的下个步骤。

#### 15.6.4 身份验证

下一步，从服务器决定是否向主服务器发送身份验证，流程如下
![](Redis-15-复制\200305_22.png)

#### 15.6.5 发送端口信息

在身份验证步骤之后，从服务器将执行命令`REPLCONF listening-port <port-number>`向主服务器发送从服务器的监听端口号

主服务器接收到这个命令后，会将端口号记录在从服务器所对应对的客户端状态的`slave_listening_port`属性中

````c
typedef struct redisClient{
    //...

    //从服务器的监听端口号
    int slave_listening_port;

    //...
} redisClient
````

#### 15.6.6 同步

在这一步，从服务器将向主服务器发送`PSYC`命令，执行同步操作，并将自己的数据库更新至主服务器数据库当前所处的状态。

`PSYC`的详细过程请参加上一节

值得一提的是，在同步操作执行之后，主服务器也会成为从服务器的客户端。正因为主服务器成为了从服务器的客户端，所以主服务器才能通过发送写命令来改变从服务器的数据库状态

如下图
![](Redis-15-复制\200305_23.png)

#### 15.6.7 命令传播

当完成了同步之后，主从服务器就会进入命令传播阶段，这时主服务器只要一直将自己执行的写命令发送给从服务器，而从服务器只要一直接收并执行主服务器发来的写命令，就可以保证主从服务器一直保持一致了。

### 15.7 心跳检测

在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送命令
````sh
REPLCONF ACK <replication_offset>
````

其中`replication_offset`命令是从服务器当前的复制偏移量

发送`REPLCONF ACK`命令对于主服务器有三个作用
- 检测主从服务器的网络连接状态
- 辅助实现`min-slaves`选项
- 检测命令丢失

#### 15.7.1 检测主从服务器的网络连接状态

主从服务器可以通过发送和接收`REPLCONF ACK`命令来检查两者之间的网络连接是否正常：如果主服务器超过一秒钟没有收到从服务器发来的 `REPLCONF ACK`命令，那么主服务器就知道主从服务器之间的连接出现问题了。

#### 15.7.2 辅助事件min-slaves配置选项

Redis的`min-s1aves-to-write`和`min-slaves-max-1ag`两个选项可以防止主服务器在不安全的情况下执行写命令。

假设我们向主服务器提供如下设置
````conf
min-slaves-to-write 3
min-slaves-max-lag 10
````
这个设置是指，如果从服务器的数量小于3，或者3个服务器的延迟值都大于或等于10秒时，主服务器将拒绝执行写命令

#### 15.7.3 检测命令丢失

如果因为网络故障，主服务器传播给从服务器的写命令在半路丢失，那么当从服务器向主服务器发送`REPLCONF ACK`命令时，主服务器将发觉从服务器当前的复制偏移量少于自己的复制偏移量，然后主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区里面找到从服务器缺少的数据，并将这些数据重新发送给从服务器。

例如下图
![](Redis-15-复制\200305_24.png)
![](Redis-15-复制\200305_25.png)
